#ifndef __SAFE_LIST_H__
#define __SAFE_LIST_H__


#include <list>

#include "thread/Lock.h"
#include "thread/AutoLock.h"
#include "common/Iterator.h"
#include "common/Iterateable.h"


namespace ns_container
{

template<typename TEle>
class SafeList : public Iterateable<TEle>
{
public:
    class SafeListIterator : public Iterator<TEle>
    {
    public:
        SafeListIterator() {}
        ~SafeListIterator() {}

        SafeListIterator& operator++()
        {
            ++_iter;
            return *this;
        }

        SafeListIterator operator++(int)
        {
            SafeListIterator temp = *this;
            ++this->_iter;
            return temp;
        }

        SafeListIterator& operator--()
        {
            --_iter;
            return *this;
        }

        SafeListIterator operator--(int)
        {
            SafeListIterator temp = *this;
            --this->_iter;
            return temp;
        }

        TEle& operator*() const
        {
            return *_iter;
        }

        TEle* operator->() const
        {
            return &(*_iter);
        }

        bool operator==(const SafeListIterator& iter) const
        {
            return this->_iter == iter->_iter;
        }

        bool operator!=(const SafeListIterator& iter) const
        {
            return this->_iter != iter->_iter;
        }

        bool operator<(const SafeListIterator& iter) const
        {
            return this->_iter < iter->_iter;
        }

    private:
        friend class SafeList;
        typename std::list<TEle>::iterator _iter;
    };
    typedef SafeListIterator iterator;

public:
    SafeList() {}
    ~SafeList() {}

    void add(TEle ele)
    {
        ns_thread::AutoLock(&_rwlock, ns_thread::RWLock::WRITE);
        _list.push_back(ele);
    }

    void extend(SafeList<TEle> lst)
    {

    }

    void erase(const TEle& ele)
    {
        ns_thread::AutoLock(&_rwlock, ns_thread::RWLock::WRITE);
        typename std::list<TEle>::iterator iter = _list.begin();

        for (; iter != _list.end(); ++iter)
        {
            if (*iter == ele)
            {
                _list.erase(iter);
                return;
            }
        }
    }

    bool find(const TEle& ele, TEle* ret)
    {
        // if (ret == NULL) 

        ns_thread::AutoLock(&_rwlock, ns_thread::RWLock::READ);
        typename std::list<TEle>::iterator iter = _list.begin();
        
        for (; iter != _list.end(); ++iter)
        {
            if (*iter == ele)
            {
                *ret = *iter;
                return true;
            }
        }
        
        return false;
    }

    bool empty()
    {
        ns_thread::AutoLock(&_rwlock, ns_thread::RWLock::READ);
        return _list.empty();
    }

    size_t size()
    {
        ns_thread::AutoLock(&_rwlock, ns_thread::RWLock::READ);
        return _list.size();
    }

    virtual SafeListIterator begin()
    {  
        SafeListIterator iter;
        iter._iter = _list.begin();
        return iter;
    }

    virtual const SafeListIterator end()
    {
        SafeListIterator iter;
        iter._iter = _list.end();
        return iter;
    }
    
private:
    std::list<TEle> _list;
    ns_thread::RWLock _rwlock;
};

}

#endif
